<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>javascript</title>
    <!--index样式-->
    <link rel="stylesheet" href="../../css/index/index.css">
    <!--bootstarp架构-->
    <link rel="stylesheet" href="../../css/bootstarp/bootstrap.css">
    <!--对于使用es6写法有多种转义方式，这个是其中一种，性能最差，通过线上文件执行转义，但是适合简单的开发测试应用-->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="../../js/jquery-3.4.1.min.js"></script>
    <script src="../../js/common/common.js"></script>
</head>
<body>
<!-- Fixed navbar -->
<nav class="navbar navbar-inverse navbar-fixed-top">
    <div class="container">
        <div class="navbar-header">
            <a class="navbar-brand">前端基础学习课件</a>
        </div>
        <div id="navbar" class="navbar-collapse collapse">
            <ul class="nav navbar-nav">
                <li><a href="../../index.html">首页基础知识</a></li>
                <li><a href="../css/index.html">深入html+css</a></li>
                <li class="active"><a>js深入</a></li>
                <li><a href="../structure/index.html">前端数据结构</a></li>
                <li><a href="../es/index.html">es6基础</a></li>
                <li><a href="../echarts/index.html">echarts测试</a></li>
                <li><a href="../d3Test/index.html">d3.js</a></li>
            </ul>
        </div>
    </div>
</nav>

<div class="container theme-showcase" role="main">
    <div>
        <div class="well">
            <p>
                js这一块，我不讲基础，主要都是js的总结以及经常适用到东西，需要对js做到总结的应该有，而且针对js的优化，就有了
                后期我们熟系而且推荐掌握的<span class="red">jquery，es6，typescript</span>
            </p>
            <p class="red">
                我认为的关系(>为包括)：typescript > es6 > js => jquery(js的封装升级)，所以如你你熟系es6的话，对于typescript
                也能非常迅速的理解，他们在类型定义，封装等很多思想上比较接近，但是，对于typescript+框架的坑那就只能靠自己了....
            </p>
            <p>首先我们要知道js的一些属性以及对应的特性</p>
            <p>
                js的两个比较大的<span class="red">特点或者说弱点</span> ：<br>
                <span class="red">1、弱类型</span><br>
                <span class="red">2、没有命名空间</span>
            </p>
            <pre>
                //js的弱类型：就是可以非常方便的改变你定义的变量的类型结构
                var ax = 11111;
                console.log(typeof ax)      //number

                ax = '11111'
                console.log(typeof ax)      //string

                ax = true
                console.log(typeof ax)      //boolean
            </pre>
            <p>
                首先是弱类型，这个在做小型项目的时候非常实用，但是做大型项目时候，
                对于之前的变量如果类型发现改变会有一些问题，所以需要固定其变量的数据类型，这种情况下就需要使用到typescript
            </p>
            <p>
                其次是js在官方没有固定的命名空间，而typescript提供了这种方式
            </p>
            <p>https://www.jianshu.com/p/d7d59bf3fda6</p>
            <ol>
                <!--实现超链接锚点-->
                <li><a>js中常用语法操作</a></li>
                <li><a>高阶函数</a></li>
                <li><a>递归函数</a></li>
                <li><a>闭包函数和定义</a></li>
                <li><a>js组件封装定义</a></li>
                <li><a>js中ajax原理</a></li>
                <li><a>js几个比较常用的事件，冒泡事件，事件捕获，默认事件</a></li>
            </ol>
            <a href="https://www.liaoxuefeng.com/wiki/1022910821149312/1023020745357888">对应参考文档</a>
            <p>
                然后你在学习js只有，jquery同时也是不可缺少的一个学习过程，简单来说，jquery就是js的升级版本，
                更加便于js语法的实现，和后面的vue.js和react.js是一个性质得，
                <span class="red">
                    所以，在你开始学习js的时候，你要有一个比较清晰的概念，知道这个架构师那种类型的，什么特点，作用等等，
                    不要像我那会一样，经常学习完了之后，还不太清楚这个学了有什么用
                </span>
            </p>
            <div>
                <h3>jquery：M-V-C架构</h3>
                <p>
                    <span class="red">Model（模型）</span>：是应用程序中用于处理应用程序数据逻辑的部分。<br>
                    　　　　通常模型对象负责在数据库中存取数据。<span class="red">(简单来说，就是管理和存数据的地方)</span><br>
                    比如我们人类有一双手，一双眼睛，一个脑袋，没有尾巴，这就是模型，Model定义了这个模块的数据模型。
                    在代码中体现为数据管理者，Model负责对数据进行获取及存放。
                    数据不可能凭空生成的，要么是从服务器上面获取到的数据，要么是本地数据库中的数据，
                    也有可能是用户在UI上填写的表单即将上传到服务器上面存放，所以需要有数据来源。
                    既然Model是数据管理者，则自然由它来负责获取数据。
                    Controller不需要关心Model是如何拿到数据的，只管调用就行了。
                    数据存放的地方是在Model，而使用数据的地方是在Controller，
                    所以Model应该提供接口供controller访问其存放的数据（通常通过.h里面的只读属性）
                </p>
                <p>
                    <span class="red">View（视图）</span>：是应用程序中处理数据显示的部分。。<br>
                    　　　　<span class="red">(简单来说，界面上看到的东西)</span><br>
                </p>
                <p>
                    <span class="red">Controller（控制器）</span>：是应用程序中处理用户交互的部分<br>
                    　　　　<span class="red">(简单来说，就是控制视图和数据之间的联系交互的)</span><br>
                </p>
            </div>
            <div>
                <h3>Model-View-ViewModel(MVVM架构)</h3>
                <p>
                    例如vue.js，react.js等最近兴起的架构思想均类似这样
                </p>
                <p>
                    modal和view的意思和上面一样，这里多出来的，就是ViewModal：
                </p>
                <p>
                    View绑定到ViewModel，然后执行一些命令在向它请求一个动作。而反过来，ViewModel跟Model通讯，告诉它更新来响应UI。这样便使得为应用构建UI非常的容易。往一个应用程序上贴一个界面越容易，外观设计师就越容易使用Blend来创建一个漂亮的界面。同时，当UI和功能越来越松耦合的时候，功能的可测试性就越来越强。
                </p>
            </div>
            <p>
                <a href="https://www.jianshu.com/p/b0aab1ffad93">参考文献</a>
            </p>
        </div>
    </div>

    <!--js事件冒泡和事件捕获-->
    <div>
        <h3>js事件冒泡和事件捕获</h3>
        <div class="well">
            <p>
                事件冒泡Bubbling：button => div2 => div1 => body => document
                <br>
                解决方法1：在点击事件的方法中开始使用event.stopPropagation(ie为cancelBubble)开始截断冒泡向上，同时也能阻止事件捕获
                <br>
                解决方法2：判断是否当前的绑定事件或者数值，如果是，就执行，不是就退出
            </p>
            <p>事件捕获Capturing：document => body => div1 => div2 => button</p>
            <p>对于事件冒泡和事件捕获的阻止和使用，其实可以通过添加监听事件，在具体的某一个地方进行隔断</p>
            <p>如果是vue.js或者是react.js中，都有各自自己的阻止api</p>
            <p>
                vue.js：@click.stop(阻止冒泡)；@click.prevent(阻止默认事件)
            </p>
            <p>
                但是对于react的阻止冒泡这些就比较有的难度一下了 <br>
                <a href="https://www.jianshu.com/p/e0894bd588f4">https://www.jianshu.com/p/e0894bd588f4</a>
                react阻止事件冒泡
            </p>

        </div>
    </div>

    <!--js事件委托-->
    <div>
        <h3 class="red">js事件委托——算是JS里比较流行的技术了</h3>
        <div class="well">
            <p>事件委托原理：它可以让我们添加监听器到父元素上，避免监听每个子元素。</p>
            <p class="red">
                第一个好处是效率高，比如，不用for循环为子元素添加事件了 <br>
                第二个好处是，js新生成的子元素也不用新为其添加事件了，程序逻辑上比较方便 <br>
            </p>
            <p>我们用一个简单的需求做比较，让下面的li每个划过的时候变色</p>
            <div class="marginTop">
                <ul id="containerCtnList">
                    <li><a href="#">Item 1</a></li>
                    <li><a href="#">Item 2</a></li>
                    <li><a href="#">Item 3</a></li>
                    <li><a href="#">Item 4</a></li>
                    <li><a href="#">Item 666</a></li>
                    <li><a href="#">Item 1000</a></li>
                </ul>
            </div>
            <pre>
                //如果是普通的做法，就通过for循环获取
                var oUl = document.getElementById('ul1');
                 var aLi = oUl.children;
                 console.log(aLi);

                 //传统方法，li身上添加事件，需要用for循环，找到每个li
                 for (var i=0;i < aLi.length; i++) {
                     aLi[i].onmouseover = function() {
                         this.style.background = 'red';
                     }
                     aLi[i].onmouseout = function(){
                         this.style.background = '';
                     }
                 }//for结束

                //但是如果通过事件冒泡把这个给他的父类拿到，然后通过父类去判断，这样就方便了很多
        let oUl = document.getElementById('containerCtnList');
        oUl.onmousemove = function (ev) {
            let oLi = ev.target;
            //通过nodeName确定获取的是否是a链接，
            // 为了确保不同浏览器下获取的字母大小写一致，所以使用toLowerCase去设置统一小写
            if (oLi.nodeName.toLowerCase() === 'li') {
                oLi.style.background = 'red';
            }
        };
        oUl.onmouseout = function (ev) {
            let oLi = ev.target;
            if (oLi.nodeName.toLowerCase() === 'li') {
                oLi.style.background = '';
            }
        };

        //额外科普一下
        document.getElementById('containerCtnList').addEventListener('click', function (e) {
            //currentTarget指向的是监听器直接绑定的那个元素，而 target 指向的是我们点击的那个元素。
            console.log(e.target);
            console.log(e.currentTarget);
            //通过nodeName确定获取的是否是a链接，
            // 为了确保不同浏览器下获取的字母大小写一致，所以使用toLowerCase去设置统一小写
            if (e.target && e.target.nodeName.toLowerCase() === 'a') {
                console.log("List item ", e.target.textContent, " was clicked!");
            }
        });
            </pre>
        </div>
    </div>

    <!--js中常用语法操作-->
    <div>
        <h3>js中常用语法操作</h3>
        <div class="well">
            <p style="color: red">字符串，数组，对象的操作</p>
            <p>涉及到字符串，数组，对象等，无非就是这这三种类型的增删改查</p>
            <p style="color: red;font-weight: bold">字符串：</p>
            <p>
                增加：<br>
                1、'ax' + 'bx' //这种是基于原字符串的修改<br>
                2、concat()： //concat：返回新字符串，原字符串不变<br>
                var str1 = 'Hello', str2 = ' World', str3 = '!';<br>
                console.log(str1.concat(str2)); // "Hello World"<br>
                console.log(str1.concat(str2,str3)); // "Hello World!"
            </p>
            <p>
            </p>
            <p>修改：split分割："2:3:4:5".split(":") //将返回["2", "3", "4", "5"]</p>
            <p>查询：indexOf <br>
                var s = 'hello, world'; <br>
                s.indexOf('world'); // 返回7 <br>
                s.indexOf('World'); // 没有找到指定的子串，返回-1
            </p>
            <p style="color: red;font-weight: bold">对象和数组对象：</p>
            <p>对象和数组都可用的删除：delete ax.bx</p>
            <p>
                数组的修改： <br>
                push，unshift， //添加，最后一项和第一项，<span class="red">原数组修改</span><br>
                pop，shift， //删除，最后一项和第一项，<span class="red">原数组修改</span><br>
                array.push(ax)， //用法都一样
                <br>
                concat()：数组上的使用和字符串上的时候类似，都是<span class="red">不改变原数组</span>，
                在新数组上加以改变，有点类似于push <br>
                let ax = [1,2,3]; let bx = [3,5,6]; <br>
                ax.concat(bx); //[1,2,3,3,5,6] <br>
            </p>
            <p>
                数组最为常用的删除方法，删除数组某一项：splice <span style="color: red">注意：这个会返回新数据，改变原数据</span> <br>
                arr.splice(index) ; :从index下标位置开始向数组后面截取，直到最后，返回截取的所有元素。 <br>
                arr.splice(index,num) ; :从index下标位置开始向数组后面截取num个元素，返回截取的所有元素。 <br>
                let ax = [1,2,3,4,5]; <br>
                document.write(ax.splice(2, 1)); //删除ax中的第二项 <br>
            </p>
        </div>
    </div>

    <!--this的问题-->
    <div>
        <h3 class="red">this (重点和难点和面试经常问的)</h3>
        <div class="well">
            <p class="red">有关this，所得是js中this的指向问题，一般来说，this就是指向当前的，表示当前对象的一个引用</p>
            <p class="red">但是实际上坑爹的是，尼玛this的实际指向是根据具体情况具体分析的</p>
            <p class="red">
                在方法或者函数中，this 表示该方法所属的对象。 (这个)<br>
                如果单独使用，this 表示全局对象。 <br>
                在函数中，this 表示全局对象。 <br>
                在函数中，在严格模式下，this 是未定义的(undefined)。 <br>
                在事件中，this 表示接收事件的元素。 <br>
                类似 call()、apply()、bind() 方法可以将 this 引用到任何对象。 (这个)<br>
                或者可以用最常用的let _this = this，来获取指向 (这个)<br>
            </p>
            <pre>
var person = {
  firstName: "John",
  lastName : "Doe",
  id       : 5566,
  fullName1 : function() {
    return this.firstName + " " + this.lastName;        //方法中，this 表示该方法(fullName)所属的对象。也就是person
  },
  firstNameTest: {
      firstName: '666',
      fullName1 : function() {
          console.log(this.firstName)                   //比如这里的this，指向的是当前对象firstNameTest，所以这里是666
      }
  },
};

var x = this;   //如果单独使用，this 表示全局对象。 在浏览器中，window 就是该全局对象为 [object Window]:

"use strict";
var x = this;   //严格模式下如果单独使用，this 也是指向全局(Global)对象。

var ax = '666'
function myFunction() {     //函数方法中(myFunction)，在浏览器中，这个方法明显是属于全局对象为 [object Window]:
  console.log(this.ax);     //666，这里的this指的是全局
  console.log(this)         //[object Window]:    //但是如果是严格模式，这里的this就是undefined
}
            </pre>
            <p>具体改变this的案例</p>
            <pre>

let obj = {
    name: '上原老师',
    age: 17,
    myFun: function (fm, t) {
        console.log(this.name + '年龄' + this.age + '和' + fm + t);
    }
};
obj.myFun();               //上原老师年龄17
let db = {
    name: '波多老师',
    age: 29
};
obj.myFun.call(db);　　　　// 波多老师 29       db是具体指向的对象
obj.myFun.apply(db);　　　 // 波多老师 29
obj.myFun.bind(db)();      // 波多老师 29
obj.myFun.call(db, '大桥老师', 666);   //波多老师年龄29和大桥老师666  //这三个后面都可以附带参数
            </pre>
        </div>
    </div>


    <!--高阶函数-->
    <div>
        <h3 class="red">高阶函数</h3>
        <div class="well">
            <div>
                <h3 class="red">

                </h3>
            </div>
            <div>
                <h3>map和reduce的使用</h3>
                <p>这个map的使用其实和<span class="red">forEach有些相识</span>，在实际使用中，主要是针对数据的操作</p>
                <img src="./image/map.png" alt="">
                <p class="marginTop">测试map平方：<span class="mapCtnTest"></span></p>
                <p id="mapCtn"></p>
                <p>再看reduce的用法。Array的reduce()把一个函数作用在这个Array的[x1, x2, x3...]上，这个函数必须接收<span class="red">两个参数</span> ，
                    reduce()把<span class="red">结果继续和序列的下一个元素做累积计算</span></p>
                <p class="red">[x1, x2, x3, x4].reduce(f) = f(f(f(x1, x2), x3), x4)</p>
                <p class="marginTop">测试reduce数组从头加到尾部：<span class="mapCtnTest"></span></p>
                <p id="reduceCtn"></p>
                <pre>
class Index {
    constructor() {

    }

    //map的使用测试：平方
    mapTest(array) {
        return array.map((ctn) => {
            return ctn * ctn
        })
    }

    //reduce的使用：用于叠加
    reduceTest(array) {
        return array.reduce((x, y) => {
            return x + y;
        })
    }
}
let init = {
    //高阶函数
    IndexTest: function () {
        let ax = [1, 3, 5, 7, 9];
        let takeCtn = new Index();
        $('.mapCtnTest').text('测试数据：' + ax);
        document.getElementById('mapCtn').innerText = `map得出结果：${(takeCtn.mapTest(ax)).map(String)}`;   //map用于数组转字符串也非常方便
        $('#reduceCtn').text('reduce结果' + takeCtn.reduceTest(ax));
    }
};
                </pre>
            </div>
            <div>
                <h3>filter</h3>
                <p>
                    filter也是一个常用的操作，它用于把Array的某些元素过滤掉，然后返回剩下的元素
                </p>
                <p>
                    科普一波：在vuex中的getters用于计算state的情况的时候，用的最多的就是filter过滤方法
                </p>
                <p>
                    最常用的写法： <br>
                    return filter((ctn, index, arr) => { return *** })；接受方式和map类似
                </p>
                <p class="red">
                    注意： filter() 不会对空数组进行检测。 <br>
                    注意： filter() 不会改变原始数组，属于返回一个新数据的情况
                </p>
                <p class="marginTop">测试数据过滤偶数：<span class="mapCtnTest"></span></p>
                <p id="filterCtn"></p>
            </div>
            <div>
                <h3>sort</h3>
                <p>这个压根就是es6里面的：Array.prototype.sort()的排序方法，用于数据排序</p>
                <p class="red">
                    sort()方法也是一个高阶函数，它还可以接收一个比较函数来实现自定义的排序。<br>
                    而对于sort()来说，他不关心比较的过程，只关心比较的结果，例如：两个元素x，y <br>
                    认为x > y，return 1 <br>
                    认为x === y, return 0 <br>
                    认为x < y，return -1 <br>
                    而sort就是根据1,0，-1这个结果去控制排序，//可以这样去记：-1是往前扔，0中间，1向后扔
                </p>
                <p class="red">简单的来说，不要直接使用sort()，最好通过自定义方法实现，不然容易掉到坑里面</p>
                <p class="marginTop">sort由大到小比较：<span class="mapCtnTest"></span></p>
                <p id="sortCtn"></p>
                <pre>
    //sort：测试sort方法
    sortTest(array) {
        return array.sort((x, y) => {
            if (x < y) {
                return 1;
            } else if (x > y) {
                return -1      //可以这样去记：-1是往前扔，0中间，1向后扔
            } else {
                return 0
            }
        });
    }
                </pre>
            </div>
            <div>
                <h3>Array数组其他方法</h3>
                <p>其中Array还包括很多我们其他常用的，比如最常见的forEach，以及find</p>
                <p class="red">注意: find() 对于空数组，函数是不会执行的；
                    注意: find() 并没有改变数组的原始值。</p>
                <p>array.find(( ctn, index, arr ) => { 自定义函数 })；参数和map，forEach类似</p>
            </div>
        </div>
    </div>

    <!--递归函数-->
    <div>
        <h3 class="red">递归函数</h3>
        <div class="well">
            <p class="red">说白了，递归就是函数自己调用自己</p>
            <p class="red">主要：使用递归函数，必须要有结束的条件，不然浏览器会崩掉</p>
            <p>测试5!：<span id="FactorialTest"></span></p>
            <pre>
    //递归：简单的阶乘
    Factorial(num) {
        if (num === 1) {
            return num
        } else {
            return  num * this.Factorial(num - 1);
        }
    }
    takeCtn.Factorial(5)
            </pre>

            <div class="marginTop">
                <p>
                    上面都是属于简单的思维，对于递归函数的使用，可以看看这个参考文件
                    <br>
                    <a href="https://blog.csdn.net/PrisonersDilemma/article/details/89451120">
                        参考文献：https://blog.csdn.net/PrisonersDilemma/article/details/89451120
                    </a>
                </p>
                <p>
                    简单来说，对于递归函数的使用，可以分为四个步骤： <br>
                    1、寻找递推关系：简单来说，就是分析递推之间互相的关系 <br>
                    2、寻找临界条件：就是直接分析相互条件的差异和结合 <br>
                    3、总结递归表达式：然后整合到一起 <br>
                    4、改写成递归函数：然后写成函数即可 <br>
                </p>
                <p id="FibonoTest"></p>
                <pre>
    //测试一个递归的案例，求斐波那契数列第n项的总和
    //首先斐波那契数列是1,1,2,3,5,8,13,21…   即第n项是前两项的和
    //这里需要求第n项到前面的总和
    //先确定第n项的值
    checkN(n) {
        if (n === 1 || n === 2) {
            return 1
        } else {
            return this.checkN(n - 1) + this.checkN(n - 2);
        }
    }
    //知道第n项后，求第n项外加之前的值
    sunCtn(n) {
        if (n === 1) {
            return n
        } else {
            return this.checkN(n) + this.sunCtn(n - 1);
        }
    }
                </pre>
            </div>
        </div>
    </div>

    <!--闭包-->
    <div>
        <h3 class="red">
            闭包函数和定义
        </h3>
        <p>
            在js中，递归和闭包的概念都是属于一个难点，但是你如果对其比较详细的了解掌握，在js编程上会有很大收获
        </p>
        <div id="getCtn" style="display: none"></div>
        <p>
            之前我们说到，递归函数属于方法中调用方法，那么闭包我对他的理解就是，<span class="red">方法中存在方法</span>，
            只有 具体调用到方法后才会执行方法里面存在的方法
        </p>
        <p>
            闭包的特性：<span class="red">当一个函数返回它内部定义的一个函数时，就产生了一个闭包，闭包不但包括被返回的函数，还包括这个函数的定义环境，</span>
        </p>
        <pre>
var   generateClosure   =   function()   {
    var   count   =   0;
    var   get   =   function()   {
        count   ++;
        return   count;
    };
    return   get;                       //这个函数返回了内部定义的函数
};

var   counter1   =   generateClosure();
var   counter2   =   generateClosure();
console.log(counter1());   //   输出   1
console.log(counter2());   //   输出   1
console.log(counter1());   //   输出   2
console.log(counter1());   //   输出   3
console.log(counter2());   //   输出   2
        </pre>
        <p id="bibao"></p>
        <p>上面这个例子解释了闭包是如何产生的： counter1和counter2分别调用了generate-Closure() 函数，<span class="red">生成了两个闭包的实例，它们内部引用的 count 变量分别属于各自的运行环境</span>。我们可以理解为，在
            generateClosure() 返回 get 函数时，私下将 get 可能引用到的 generateClosure() 函数的内部变量（也就是 count 变量）也返回了，并在内存中生成了一个副本，之后
            generateClosure() 返回的函数的两个实例 counter1和 counter2 就是<span class="red">相互独立</span>的了。</p>
        <a href="https://www.haorooms.com/post/js_bb" target="_blank">https://www.haorooms.com/post/js_bb</a>
    </div>

    <!--javascript的异步编程-->
    <div>
        <h3 class="red">
            重点：javascript的异步编程
        </h3>
        <div>
            <p>具体的异步详细案例，在es6菜单下会有案例详细讲解</p>
            <ul class="marginTop">
                <li class="red">JS 异步编程进化史：callback -> promise -> generator -> async + await</li>
                <li class="red">async/await 函数的实现，就是将 Generator 函数和自动执行器，包装在一个函数里</li>
                <li class="red">async/await可以说是异步终极解决方案了</li>
            </ul>
            <div>
                <span class="red">async/await函数相对于Promise，优势体现在：</span>
                <p>
                    处理 then 的调用链，能够更清晰准确的写出代码；并且也能优雅地解决回调地狱问题。
                </p>
                <p>
                    当然async/await函数也存在一些缺点，因为 await 将异步代码改造成了同步代码，如果多个异步代码没有依赖性却使用了 await 会导致性能上的降低，代码没有依赖性的话，完全可以使用
                    Promise.all 的方式
                </p>
                <p>
                    async/await函数对 Generator 函数的改进，体现在以下三点：
                    内置执行器。
                    Generator 函数的执行必须靠执行器，所以才有了 co 函数库，而 async 函数自带执行器。也就是说，async 函数的执行，与普通函数一模一样，只要一行。
                    <br>
                    更广的适用性。 co 函数库约定，yield 命令后面只能是 Thunk 函数或 Promise 对象，而 async 函数的 await 命令后面，可以跟 Promise
                    对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。
                    <br>
                    更好的语义。 async 和 await，比起星号和 yield，语义更清楚了。async 表示函数里有异步操作，await 表示紧跟在后面的表达式需要等待结果。
                </p>
                <p>https://www.jianshu.com/p/d7f6077a0dd2</p>
            </div>
        </div>
    </div>
</div>
</body>
<script src="./index.js" type="text/babel"></script>
</html>
