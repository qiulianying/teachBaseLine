<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>es6基础</title>
    <!--index样式-->
    <link rel="stylesheet" href="../../css/index/index.css">
    <!--bootstarp架构-->
    <link rel="stylesheet" href="../../css/bootstarp/bootstrap.css">
    <!--对于使用es6写法有多种转义方式，这个是其中一种，性能最差，通过线上文件执行转义，但是适合简单的开发测试应用-->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="../../js/common/common.js"></script>
</head>
<body>
<!-- Fixed navbar -->
<nav class="navbar navbar-inverse navbar-fixed-top">
    <div class="container">
        <div class="navbar-header">
            <a class="navbar-brand">前端基础学习课件</a>
        </div>
        <div id="navbar" class="navbar-collapse collapse">
            <ul class="nav navbar-nav">
                <li><a href="../../index.html">首页基础知识</a></li>
                <li><a href="../css/index.html">深入html+css</a></li>
                <li><a href="../javascript/index.html">js深入</a></li>
                <li><a href="../structure/index.html">前端数据结构</a></li>
                <li class="active"><a href="../es/index.html">es6基础</a></li>
                <li><a href="../echarts/index.html">echarts测试</a></li>
                <li><a href="../d3Test/index.html">d3.js</a></li>
            </ul>
        </div>
    </div>
</nav>

<div class="container theme-showcase" role="main">
    <div class="jumbotron">
        <h2>es6基础和我在项目中总结的常用注意</h2>
        <p>
            下面介绍的都不是基础，如果想看基础，推荐文档：<a href="https://es6.ruanyifeng.com/#docs/set-map">https://es6.ruanyifeng.com/#docs/set-map</a>
        </p>
        <p>
            这里介绍的都是es6中我觉得作用比较大的注意点，前端结构的常用以及主要知识点，相当于归纳总结
        </p>
    </div>
    <div>
        <div class="page-header">
            <h3>set</h3>
        </div>
        <div class="well">
            <p>
                有关es6的，这个最好在在你对javascript有了一定的深入了解之后，再来学习es6会好一些，不然你也只是一脸闷逼，
                这个我在后期会进行总结和归纳，下面我先列一些需要总结归纳的点
            </p>
            <ol>
                <li>箭头函数</li>
                <li class="red">有关es6异步处理(重点和难点)：promise，async函数等</li>
                <li>set</li>
                <li>... 符号运算</li>
                <li>在具体项目结构中，可以使用到的es6</li>
            </ol>
        </div>
    </div>

    <div>
        <div class="page-header">
            <h3>箭头函数</h3>
        </div>
        <div class="well">
            <p>
                首先先来撸清楚箭头函数和普通函数写法上的区别
            </p>
            <pre>
//无参数
let fn = function(){
    return 'helloWorld';
}
//简写为：
let fn = ()=>{//但是没有参数时，括号不可以省略
    return 'helloWorld';
}
//根据规则二，简写为：
let fn = ()=>'helloWorld';



//一个参数
let fn = function(a){
    return a;
}
//简写为：
let fn = (a)=>{
    return a;
}
//根据规则一，还可以简写为：
let fn = a=>{
    return a;
}
//根据规则二，还可以简写为：
let fn = a=>a;



//多个参数
let fn = function(a,b){
    return a+b;
}
//简写为：
let fn = (a,b)=>{//多于一个参数，圆括号不可省略
    return a+b;
}
//根据规则二，还可以简写为：
let fn = (a,b)=>a+b;
            </pre>
            <p>Promise 新建后就会立即执行。</p>
            <pre>
let promise = new Promise(function(resolve, reject) {
  console.log('Promise');
  resolve();
});

promise.then(function() {
  console.log('resolved.');
});

console.log('Hi!');

// Promise
// Hi!
// resolved
            </pre>
        </div>
    </div>

    <div>
        <div class="page-header">
            <h3>Promise 对象</h3>
        </div>
        <div class="well">
            <p class="red">
                首先：对于异步处理的最多的就是接口，不过现在，接口的情况大部分都是通过封装axios来解决了，这样也比较快，
                但是如果说在非接口的js函数调用的时候存在异步问题，那么，es6中的这类语法就是最好的解决方法
            </p>
            <p>
                所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的
                API，各种异步操作都可以用同样的方法进行处理。
            </p>
            <pre>
const promise = new Promise(function(resolve, reject) {
  // ... some code

  if (/* 异步操作成功 */){
    resolve(value);
  } else {
    reject(error);
  }
});
            </pre>
            <p class="red">
                Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。
                感觉有关平时使用axios的then使用机制就是类似这样的
            </p>
            <p>
                resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为
                resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为
                rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。
            </p>
            <pre>
promise.then(function(value) {
  // success
}, function(error) {
  // failure
});
            </pre>
            <pre>
//测试es6中promise对象
let testPromise = function () {
    function timeout(ms) {
        return new Promise((resolve, reject) => {
            setTimeout(resolve, ms , '异步结束')
        })
    }

    timeout(3000).then(value => {
        document.getElementById('testPromise').innerText = '3秒后得到内容：' + value
    })
};
            </pre>
            <div>执行情况：<span id="testPromise"></span></div>
            <p>下面是对执行异步情况的一个反馈：创建的promise会被立即执行，然后成功之后，才是执行异步</p>
            <pre>
let promise = new Promise(function(resolve, reject) {
  console.log('Promise');
  resolve();
});

promise.then(function() {
  console.log('resolved.');
});

console.log('Hi!');

// Promise
// Hi!
// resolved
            </pre>
            <p>
                测试promise中resolve其他promise的情况：注意：这里p2的resolve能否回调执行出来，取决于p1的resolve什么时候出来
            </p>
            <p class="red">
                那也可以理解为，p2的回调的状态，被p1的状态取代和决定
            </p>
            <pre>
const p1 = new Promise(function (resolve, reject) {
    console.log('这里是p1');
    resolve();
});

const p2 = new Promise(function (resolve, reject) {
    console.log('这里是p2');
    resolve(p1);
});

p2.then(() => {
    console.log('这里是p2已经执行返回了')
})
//这里是p1
//这里是p2
//这里是p2已经执行返回了
            </pre>
            <div class="marginTop">
                <h3>对于promise我个人的总结如下</h3>
                <ol class="red">
                    <li>promise对象创建之后立即执行</li>
                    <li>promise通过resolve和reject来回调告诉执行情况</li>
                    <li>回调函数可以通过then()方法来处理</li>
                </ol>
            </div>
        </div>
    </div>

    <div>
        <div class="page-header">
            <h3>async 函数</h3>
        </div>
        <div class="well">
            <p>
                首先先来撸清楚箭头函数和普通函数写法上的区别
            </p>
        </div>
    </div>

    <div>
        <div class="page-header">
            <h3>隐藏的book</h3>
        </div>
        <div style="margin-bottom: 20px">
            <button type="button" class="btn btn-primary" id="myModal">点击查看</button>
        </div>
        <div class="well" id="bookTake" style="display: none"></div>
    </div>
</div>
</body>
<script src="./index.js" type="text/babel"></script>
</html>
